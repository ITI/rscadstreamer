Experiment specific plugins must implement the plugin interface.  Currently,
the plugin system implements 6 "hook points."  Plugin developers may implement
none (though that's useless) up to all 6 hooks.

A plugin MUST subclass rscadplugin.RSCADPlugin.  By doing so, your class
automatically becomes a valid plugin.  Each of the hook points are implemented
as methods of this class.  A developer may implement more than one plugin class
per module.

Hooks
---------

options(argparse.Parser)

    The options hook allows a plugin developer to add recognized command line
    options.  Note, these options will not be displayed when using the --help
    option to rscadstreamer.  An argparse ArgumentParser is passed to this
    method.  See argparse doc for information on interacting with
    ArgumentParser.

    The parser should be modified in place.  The calling system will take care
    of parsing arguments for you.

init(args)

    The init hook is for plugin initialization.  The developer should perform
    any initialization, such as opening files, connecting to remote servers,
    etc. in this method.

    args is a namespace object (as returned by argparse).  Any command line
    options added in the options hook will be available here.  Again, see
    argparse docs for more on interacting with the namespace object.

    init() should return a dict containing the additional (optional) hooks and
    the handler for them.  For instance:

    return {
      'output': self.handle_output,
      'input': self.handle_input,
      'cleanup': self.cleanup,
      'commands': {
          'myplugin:foo': self.handle_foo_command
      },
    }


filter (string)

    A filter function can modify incoming data before it is passed to the
    input handler. Return the modified string

input (sting)
    Passed a string.  The data generated by RSCAD. Called for each line of
    output generated by RSCAD.  Plugin developer may do anything desired with
    this line.  

commands(command, rscad)
    These are commands that can be received from the control applications.  Commands should be in the for of 'plugin:command' to avoid collisions.

    command handlers are passed the command that was called for and a reference to the rscad object.


Note:  The system is built around PyEV, so developers may attach any additional handlers to the default_loop (including creating sub-loops).  This should be done in init().  For additional details see rtds.rscad.py and rtds.streamer2.py.
